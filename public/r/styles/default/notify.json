{
  "name": "notify",
  "type": "registry:ui",
  "dependencies": [
    "lucide-react",
    "framer-motion",
    "class-variance-authority"
  ],
  "registryDependencies": [
    "utils"
  ],
  "files": [
    {
      "path": "reusables/toast/notify.tsx",
      "content": "\"use client\";\nimport { cn } from \"@/lib/utils\";\nimport { cva } from \"class-variance-authority\";\nimport { Loader, LoaderCircle, X } from \"lucide-react\";\nimport * as React from \"react\";\nimport { ToastClassNames, ToastParams } from \"./notify-provider\";\n\nexport const statusStyles = {\n  error:\n    \"dark:bg-[#24161b] bg-[#fff5f5] text-red-900 dark:text-[#ffdfdd] dark:border-red-900 border-red-200\",\n  warning:\n    \"dark:bg-[#1E1A1B] bg-[#fefae1] text-[#3b2212] dark:text-[#EADB90] dark:border-[#5C431B] border-[#ddcab8]\",\n  success:\n    \"dark:bg-[#131d1e] bg-[#e7fef6] text-[#0d311e] dark:text-[#abf9de] dark:border-[#1e5643] border-green-200\",\n  info: \"dark:bg-[#161831] bg-[#edf4ff] text-[#1e3a8a] dark:text-[#DCE6FF] dark:border-[#2f3873] pborder-[#bfdbfe]\",\n  default:\n    \"dark:bg-[#13141b] bg-white text-gray-900 dark:text-[#e4e5e9] dark:border-[#3a3c4a] border-gray-200\",\n  loading: \"bg-white text-gray-900 border-gray-200  \",\n} as const;\n\nconst toastVariants = cva(\n  \"relative flex w-full flex-col gap-1 rounded-lg border p-[0.75rem] overflow-hidden shadow-lg \",\n  {\n    variants: {\n      status: statusStyles,\n    },\n    defaultVariants: {\n      status: \"default\",\n    },\n  }\n);\n\nconst progressBarVariants = cva(\"absolute bottom-0 left-0 h-[2px] \", {\n  variants: {\n    status: {\n      error: \"dark:bg-[#f77a6f] bg-red-600\",\n      warning: \"dark:bg-[#fabe20] bg-yellow-500\",\n      success: \"dark:bg-[#12f0a5] bg-green-600\",\n      info: \"dark:bg-[#7898ff] bg-blue-600\",\n      default: \"bg-gray-600 dark:bg-[#e4e5e9]\",\n    },\n  },\n  defaultVariants: {\n    status: \"default\",\n  },\n});\n\nconst ToastTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement> & { title: string }\n>(({ title, className, ...props }, ref) => (\n  <p\n    ref={ref}\n    className={cn(\n      \"leading-none text-[0.8125rem] mr-auto font-medium tracking-tight\",\n      className\n    )}\n    {...props}\n  >\n    {title}\n  </p>\n));\n\nconst ToastDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement> & {\n    description?: ToastParams[\"description\"];\n    status: ToastParams[\"status\"];\n  }\n>(({ description, status, className, ...props }, ref) => {\n  if (!description || status === \"loading\") return null;\n  return (\n    <p\n      ref={ref}\n      className={cn(\"text-[0.8125rem] opacity-80\", className)}\n      {...props}\n    >\n      {description}\n    </p>\n  );\n});\n\nconst ToastCloseButton = React.forwardRef<\n  HTMLButtonElement,\n  React.ButtonHTMLAttributes<HTMLButtonElement> & {\n    onClose: () => void;\n    status: string;\n  }\n>(({ onClose, status, className, ...props }, ref) => {\n  if (status === \"loading\") return null;\n  return (\n    <button\n      ref={ref}\n      onClick={onClose}\n      className={cn(\n        \"rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n        className\n      )}\n      {...props}\n    >\n      <X className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Close</span>\n    </button>\n  );\n});\n\ntype ToastLoaderProps = {\n  status: string;\n  variant?: ToastParams[\"loaderVariant\"];\n  className?: string;\n};\n\nconst ToastLoader = ({\n  status,\n  variant = \"loader-1\",\n  className,\n}: ToastLoaderProps) => {\n  if (status !== \"loading\") return null;\n  const baseClass = \"animate-spin size-4 text-black\";\n\n  return variant === \"loader-2\" ? (\n    <LoaderCircle className={cn(baseClass, className)} />\n  ) : (\n    <Loader className={cn(baseClass, className)} />\n  );\n};\n\nconst ToastProgressBar = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & {\n    duration?: number;\n    status: ToastParams[\"status\"];\n    hideProgressBar?: boolean;\n  }\n>(({ duration, status, hideProgressBar, className, ...props }, ref) => {\n  if (!duration || status === \"loading\" || hideProgressBar) return null;\n  return (\n    <div\n      ref={ref}\n      className={cn(progressBarVariants({ status }), className)}\n      style={{\n        animation: `shrink ${duration}ms linear forwards`,\n      }}\n      {...props}\n    >\n      <style>\n        {`\n          @keyframes shrink {\n            from { width: 0%; }\n            to { width: 100%; }\n          }\n        `}\n      </style>\n    </div>\n  );\n});\n\nexport function Toast({\n  closable,\n  description,\n  duration,\n  onClose,\n  title,\n  status = \"default\",\n  loaderVariant,\n  classNames = {},\n  hideProgressBar,\n}: ToastParams & { classNames?: ToastClassNames }) {\n  return (\n    <div\n      className={cn(\n        toastVariants({ status }),\n        classNames[status as keyof ToastClassNames]\n      )}\n      role={status === \"error\" ? \"alert\" : \"status\"}\n    >\n      <div className=\"flex items-center w-full\">\n        <ToastLoader\n          status={status}\n          className={cn(\"mr-2\", classNames.loader)}\n          variant={loaderVariant}\n        />\n        <ToastTitle title={title} className={classNames.title} />\n        {closable && (\n          <ToastCloseButton\n            onClose={onClose!}\n            status={status}\n            className={classNames.closeButton}\n          />\n        )}\n      </div>\n\n      <ToastDescription\n        description={description}\n        status={status}\n        className={classNames.description}\n      />\n      <ToastProgressBar\n        duration={duration}\n        status={status}\n        hideProgressBar={hideProgressBar}\n        className={classNames.progressBar}\n      />\n    </div>\n  );\n}\nToast.displayName = \"Toast\";\nToastTitle.displayName = \"ToastTitle\";\nToastDescription.displayName = \"ToastDescription\";\nToastCloseButton.displayName = \"ToastCloseButton\";\nToastLoader.displayName = \"ToastLoader\";\nToastProgressBar.displayName = \"ToastProgressBar\";\n",
      "type": "registry:ui"
    },
    {
      "path": "reusables/toast/notify-provider.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport { cva, VariantProps } from \"class-variance-authority\";\nimport { AnimatePresence, motion } from \"framer-motion\";\nimport { useEffect, useMemo, useRef, useState } from \"react\";\nimport { Toast } from \"./notify\";\nimport { toast } from \"./notify-utils\";\n\nexport const DEFAULT_CONFIG = {\n  duration: 4000,\n  position: \"bottom-right\",\n  closable: true,\n  preventDuplicates: false,\n  maxToast: 4,\n  hideProgressBar: false,\n} as const;\n\nconst toastPositionVariants = cva(\"absolute max-w-[420px] w-full p-4 md:p-8 \", {\n  variants: {\n    position: {\n      \"top-left\": \"top-0 md:top-0 left-0\",\n      \"top-center\": \"top-0 md:top-0 left-1/2 transform -translate-x-1/2\",\n      \"top-right\": \"top-0 md:top-0 right-0\",\n      \"bottom-left\": \"bottom-0 md:bottom-0 left-0\",\n      \"bottom-center\":\n        \"bottom-0 md:bottom-0 left-1/2 transform -translate-x-1/2\",\n      \"bottom-right\": \"bottom-0 md:bottom-0 right-0\",\n    },\n  },\n  defaultVariants: {\n    position: DEFAULT_CONFIG.position,\n  },\n});\n\ntype ToastPosition = VariantProps<typeof toastPositionVariants>[\"position\"];\n\ninterface ToastState {\n  dismiss: () => void;\n  id: string;\n  params: ToastParams;\n  position?: ToastPosition;\n}\n\nexport interface ToastParams {\n  closable?: boolean;\n  classNames?: ToastClassNames;\n  description?: React.ReactNode;\n  duration?: number;\n  id?: string;\n  onClose?: () => void;\n  title: string;\n  status?: \"error\" | \"warning\" | \"success\" | \"info\" | \"default\" | \"loading\";\n  loaderVariant?: \"loader-1\" | \"loader-2\";\n  position?: ToastPosition;\n  hideProgressBar?: boolean;\n  preventDuplicates?: boolean;\n  maxToast?: number;\n}\n\nexport interface ToastPromiseOptions<T> {\n  loading: string;\n  success: (data: T) => string;\n  error?: string;\n  position?: ToastPosition;\n  duration?: number;\n  classNames?: ToastClassNames;\n}\n\nexport interface ToastClassNames {\n  error?: string;\n  success?: string;\n  warning?: string;\n  info?: string;\n  loading?: string;\n  closeButton?: string;\n  title?: string;\n  description?: string;\n  loader?: string;\n  progressBar?: string;\n  containerClassName?: string;\n}\n\n// ID Generator\nlet toastId = 0;\nconst generateId = () => String(toastId++);\n\n// Add this interface before the ToastProvider component\nexport interface ToastProviderProps {\n  children: React.ReactNode;\n  position?: ToastPosition;\n  duration?: number;\n  classNames?: ToastClassNames;\n  closable?: boolean;\n  preventDuplicates?: boolean;\n  maxToast?: number;\n  hideProgressBar?: boolean;\n}\n\n// Provider Component\nexport function ToastProvider({\n  children,\n  position: defaultPosition = DEFAULT_CONFIG.position,\n  duration = DEFAULT_CONFIG.duration,\n  classNames = {},\n  closable = DEFAULT_CONFIG.closable,\n  preventDuplicates = DEFAULT_CONFIG.preventDuplicates,\n  maxToast = DEFAULT_CONFIG.maxToast,\n  hideProgressBar = DEFAULT_CONFIG.hideProgressBar,\n}: ToastProviderProps) {\n  const [toasts, setToasts] = useState<ToastState[]>([]);\n  const toastsRef = useRef<{ [key: string]: NodeJS.Timeout }>({});\n\n  // Optimized grouping of toasts by position\n  const toastsByPosition = useMemo(() => {\n    const positions = {} as Record<string, ToastState[]>;\n    for (const toast of toasts) {\n      const position = toast.params.position ?? defaultPosition;\n      positions[position!] = positions[position!] || [];\n      positions[position!].push(toast);\n    }\n    return positions;\n  }, [toasts, defaultPosition]);\n\n  // Using void operator since we only care about the side-effect of setting up handlers\n  // and not the returned value from useMemo\n  void useMemo(() => {\n    const createDismiss = (id: string) => () => {\n      setToasts((prev) => prev.filter((t) => t.id !== id));\n      if (toastsRef.current[id]) {\n        clearTimeout(toastsRef.current[id]);\n        delete toastsRef.current[id];\n      }\n    };\n\n    const push = (params: ToastParams) => {\n      const id = params.id ?? generateId();\n      const toastDuration = params.duration ?? duration;\n\n      // Check for duplicates if preventDuplicates is enabled\n      if (params.preventDuplicates ?? preventDuplicates) {\n        const isDuplicate = toasts.some(\n          (toast) => toast.params.title === params.title\n        );\n        if (isDuplicate) return id;\n      }\n\n      const dismiss = createDismiss(id);\n\n      setToasts((prev) => {\n        // Remove oldest toasts if exceeding maxToast\n        const filteredToasts = prev.filter((t) => t.id !== id);\n        const newToast = {\n          dismiss,\n          id,\n          params: {\n            ...params,\n            duration: toastDuration,\n            closable: params.closable ?? closable,\n            hideProgressBar: params.hideProgressBar ?? hideProgressBar,\n            classNames,\n            position: params.position ?? defaultPosition,\n          },\n        };\n\n        const updatedToasts = [newToast, ...filteredToasts];\n        return updatedToasts.slice(0, params.maxToast ?? maxToast);\n      });\n\n      if (toastsRef.current[id]) {\n        clearTimeout(toastsRef.current[id]);\n      }\n\n      if (toastDuration !== Infinity) {\n        toastsRef.current[id] = setTimeout(dismiss, toastDuration);\n      }\n\n      return id;\n    };\n\n    const pushPromise = <T,>(\n      promise: () => Promise<T>,\n      options: ToastPromiseOptions<T>\n    ) => {\n      const id = generateId();\n      const dismiss = createDismiss(id);\n      const position = options.position;\n      const toastDuration = options.duration ?? duration;\n      const toastClassNames = options.classNames ?? classNames;\n\n      push({\n        status: \"loading\",\n        title: options.loading,\n        id,\n        position,\n        classNames: toastClassNames,\n        duration: toastDuration,\n      });\n\n      promise()\n        .then((data) => {\n          // Clear any existing timeout\n          if (toastsRef.current[id]) {\n            clearTimeout(toastsRef.current[id]);\n          }\n\n          setToasts((prev) => [\n            {\n              dismiss,\n              id,\n              params: {\n                status: \"success\",\n                title: options.success(data),\n                duration: toastDuration, // Reset full duration\n                closable: true,\n                classNames: toastClassNames,\n                position,\n                hideProgressBar: hideProgressBar,\n              },\n            },\n            ...prev.filter((t) => t.id !== id),\n          ]);\n\n          // Set new timeout with full duration\n          if (toastDuration !== Infinity) {\n            toastsRef.current[id] = setTimeout(dismiss, toastDuration);\n          }\n        })\n        .catch(() => {\n          // Clear any existing timeout\n          if (toastsRef.current[id]) {\n            clearTimeout(toastsRef.current[id]);\n          }\n\n          setToasts((prev) => [\n            {\n              dismiss,\n              id,\n              params: {\n                status: \"error\",\n                title: options.error ?? \"Error\",\n                duration: toastDuration, // Reset full duration\n                classNames: toastClassNames,\n                position,\n                hideProgressBar: hideProgressBar,\n              },\n            },\n            ...prev.filter((t) => t.id !== id),\n          ]);\n\n          // Set new timeout with full duration\n          if (toastDuration !== Infinity) {\n            toastsRef.current[id] = setTimeout(dismiss, toastDuration);\n          }\n        });\n\n      return id;\n    };\n\n    toast.setHandlers(push, pushPromise);\n    return toast;\n  }, [\n    duration,\n    classNames,\n    closable,\n    defaultPosition,\n    preventDuplicates,\n    maxToast,\n    hideProgressBar,\n    toasts,\n  ]);\n\n  useEffect(() => {\n    return () => {\n      Object.values(toastsRef.current).forEach(clearTimeout);\n      toastsRef.current = {};\n    };\n  }, []);\n\n  return (\n    <>\n      {children}\n      <div\n        role=\"alert\"\n        aria-live=\"polite\"\n        className=\"fixed inset-0 pointer-events-none z-[999999]\"\n      >\n        {Object.entries(toastsByPosition).map(([position, positionToasts]) => (\n          <div\n            key={position}\n            className={cn(\n              toastPositionVariants({\n                position: position as ToastPosition,\n              }),\n              classNames.containerClassName\n            )}\n          >\n            <AnimatePresence>\n              {positionToasts.map(({ dismiss, id, params }, index) => {\n                const isTop = position?.includes(\"top\");\n                return (\n                  <motion.div\n                    key={id}\n                    layout\n                    initial={{ opacity: 0, y: isTop ? -80 : 80, scale: 0.85 }}\n                    animate={{ opacity: 1, y: 0, scale: 1 }}\n                    exit={{\n                      opacity: 0,\n                      scale: 0.5,\n                      y: isTop ? -80 : 80,\n                      transition: { duration: 0.2 },\n                    }}\n                    transition={{}}\n                    className=\"mb-3.5 last:mb-0 pointer-events-auto\"\n                    style={{\n                      zIndex: positionToasts.length - index,\n                    }}\n                  >\n                    <Toast {...params} onClose={dismiss} />\n                  </motion.div>\n                );\n              })}\n            </AnimatePresence>\n          </div>\n        ))}\n      </div>\n    </>\n  );\n}\n\nexport { toast };\n",
      "type": "registry:ui"
    },
    {
      "path": "reusables/toast/notify-utils.ts",
      "content": "import type { ToastParams, ToastPromiseOptions } from \"./notify-provider\";\n\nexport type ToastFunction = (\n  title: string,\n  options?: Partial<ToastParams>\n) => string;\n\ntype PromiseHandler = <T>(\n  promise: () => Promise<T>,\n  options: ToastPromiseOptions<T>\n) => string;\n\nexport interface ToastMethods {\n  success: ToastFunction;\n  error: ToastFunction;\n  warning: ToastFunction;\n  info: ToastFunction;\n  loading: ToastFunction;\n  default: ToastFunction;\n  push: (params: ToastParams) => string;\n  promise: PromiseHandler;\n}\n\nclass Toast implements ToastMethods {\n  private emit: ((params: ToastParams) => string) | null = null;\n  private emitPromise: PromiseHandler | null = null;\n\n  setHandlers(\n    emit: (params: ToastParams) => string,\n    promiseHandler: PromiseHandler\n  ) {\n    this.emit = emit;\n    this.emitPromise = promiseHandler;\n  }\n\n  private createToastFn(status: ToastParams[\"status\"]): ToastFunction {\n    return (title, options = {}) => {\n      if (!this.emit)\n        throw new Error(\n          \"Toast not initialized: wrap your app with ToastProvider\"\n        );\n      return this.emit({\n        title,\n        status,\n        ...options,\n      });\n    };\n  }\n\n  /**\n   * Display a success toast notification\n   * @param title - The main message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.success('Profile updated successfully')\n   * toast.success('Files uploaded', { duration: 5000, description: '3 files uploaded' })\n   */\n  success = this.createToastFn(\"success\");\n\n  /**\n   * Display an error toast notification\n   * @param title - The error message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.error('Failed to save changes')\n   * toast.error('Upload failed', { description: 'Network error occurred' })\n   */\n  error = this.createToastFn(\"error\");\n\n  /**\n   * Display a warning toast notification\n   * @param title - The warning message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.warning('Low storage space')\n   * toast.warning('Session expiring', { description: 'Please save your work' })\n   */\n  warning = this.createToastFn(\"warning\");\n\n  /**\n   * Display an info toast notification\n   * @param title - The information message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.info('New updates available')\n   * toast.info('Tips', { description: 'Swipe left to delete' })\n   */\n  info = this.createToastFn(\"info\");\n\n  /**\n   * Display a loading toast notification\n   * @param title - The loading message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.loading('Uploading files...')\n   * toast.loading('Processing', { duration: Infinity })\n   */\n  loading = this.createToastFn(\"loading\");\n\n  /**\n   * Display a default toast notification\n   * @param title - The message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.default('Something happened')\n   */\n  default = this.createToastFn(\"default\");\n\n  /**\n   * Create a custom toast notification with full control over its properties\n   * @param params - Complete toast parameters\n   * @example\n   * toast.push({\n   *   title: 'Custom Toast',\n   *   status: 'info',\n   *   duration: 3000,\n   *   description: 'This is a custom toast',\n   *   position: 'top-right'\n   * })\n   */\n  push = (params: ToastParams) => {\n    if (!this.emit)\n      throw new Error(\n        \"Toast not initialized: wrap your app with ToastProvider\"\n      );\n    return this.emit(params);\n  };\n\n  /**\n   * Handle async operations with loading, success, and error states\n   * @param promise - Function that returns a promise\n   * @param options - Configuration for different states of the promise\n   * @example\n   * toast.promise(\n   *   () => fetchUserData(),\n   *   {\n   *     loading: 'Fetching user...',\n   *     success: (data) => `Welcome ${data.name}!`,\n   *     error: 'Failed to fetch user'\n   *   }\n   * )\n   */\n  promise = <T>(promise: () => Promise<T>, options: ToastPromiseOptions<T>) => {\n    if (!this.emitPromise)\n      throw new Error(\n        \"Toast not initialized: wrap your app with ToastProvider\"\n      );\n    return this.emitPromise(promise, options);\n  };\n}\n\nexport const toast = new Toast();\n",
      "type": "registry:ui"
    }
  ]
}