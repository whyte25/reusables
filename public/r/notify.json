{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "notify",
  "type": "registry:ui",
  "dependencies": ["lucide-react", "framer-motion", "class-variance-authority"],
  "registryDependencies": ["utils"],
  "files": [
    {
      "path": "registry/reusables/ui/notify/notify.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { cva } from \"class-variance-authority\"\nimport { Loader, LoaderCircle, X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nimport type { ToastClassNames, ToastParams } from \"./notify-provider\"\n\nexport const statusStyles = {\n  error:\n    \"dark:bg-[#24161b] bg-[#fff5f5] text-red-900 dark:text-[#ffdfdd] dark:border-red-900 border-red-200\",\n  warning:\n    \"dark:bg-[#1E1A1B] bg-[#fefae1] text-[#3b2212] dark:text-[#EADB90] dark:border-[#5C431B] border-[#ddcab8]\",\n  success:\n    \"dark:bg-[#131d1e] bg-[#e7fef6] text-[#0d311e] dark:text-[#abf9de] dark:border-[#1e5643] border-green-200\",\n  info: \"dark:bg-[#161831] bg-[#edf4ff] text-[#1e3a8a] dark:text-[#DCE6FF] dark:border-[#2f3873] pborder-[#bfdbfe]\",\n  default:\n    \"dark:bg-[#13141b] bg-white text-gray-900 dark:text-[#e4e5e9] dark:border-[#3a3c4a] border-gray-200\",\n  loading: \"bg-white text-gray-900 border-gray-200  \",\n} as const\n\nconst toastVariants = cva(\n  \"relative flex w-full flex-col gap-1 overflow-hidden rounded-lg border p-[0.75rem] shadow-lg\",\n  {\n    variants: {\n      status: statusStyles,\n    },\n    defaultVariants: {\n      status: \"default\",\n    },\n  }\n)\n\nconst progressBarVariants = cva(\"absolute bottom-0 left-0 h-[2px]\", {\n  variants: {\n    status: {\n      error: \"bg-red-600 dark:bg-[#f77a6f]\",\n      warning: \"bg-yellow-500 dark:bg-[#fabe20]\",\n      success: \"bg-green-600 dark:bg-[#12f0a5]\",\n      info: \"bg-blue-600 dark:bg-[#7898ff]\",\n      default: \"bg-gray-600 dark:bg-[#e4e5e9]\",\n    },\n  },\n  defaultVariants: {\n    status: \"default\",\n  },\n})\n\nconst toastActionVariants = cva(\n  \"inline-flex items-center justify-center rounded-md px-3 py-1.5 text-sm font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        primary:\n          \"bg-white text-black hover:bg-white/90 dark:text-black dark:hover:bg-white/90\",\n        dismiss: \"bg-transparent hover:bg-black/10 dark:hover:bg-white/10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"primary\",\n    },\n  }\n)\n\nconst ToastTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement> & { text: React.ReactNode }\n>(({ text, className, ...props }, ref) => (\n  <p\n    ref={ref}\n    className={cn(\"mr-auto text-sm font-medium\", className)}\n    {...props}\n  >\n    {text}\n  </p>\n))\n\nconst ToastDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement> & {\n    description?: ToastParams[\"description\"]\n    status: ToastParams[\"status\"]\n  }\n>(({ description, status, className, ...props }, ref) => {\n  if (!description || status === \"loading\") return null\n  return (\n    <p\n      ref={ref}\n      className={cn(\"text-[0.8125rem] leading-5 opacity-80\", className)}\n      {...props}\n    >\n      {description}\n    </p>\n  )\n})\n\nconst ToastCloseButton = React.forwardRef<\n  HTMLButtonElement,\n  React.ButtonHTMLAttributes<HTMLButtonElement> & {\n    onClose: () => void\n    status: string\n  }\n>(({ onClose, status, className, ...props }, ref) => {\n  if (status === \"loading\") return null\n  return (\n    <button\n      ref={ref}\n      onClick={onClose}\n      className={cn(\n        \"cursor-pointer rounded-sm p-1 opacity-90 ring-offset-background transition-opacity hover:bg-black/5 hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 dark:opacity-70 dark:hover:bg-white/10\",\n        className\n      )}\n      {...props}\n    >\n      <X className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Close</span>\n    </button>\n  )\n})\n\ntype ToastLoaderProps = {\n  status: string\n  variant?: ToastParams[\"loaderVariant\"]\n  className?: string\n}\n\nconst ToastLoader = ({\n  status,\n  variant = \"loader-1\",\n  className,\n}: ToastLoaderProps) => {\n  if (status !== \"loading\") return null\n  const baseClass = \"animate-spin size-4 text-black\"\n\n  return variant === \"loader-2\" ?\n      <LoaderCircle className={cn(baseClass, className)} />\n    : <Loader className={cn(baseClass, className)} />\n}\n\nconst ToastProgressBar = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & {\n    duration?: number\n    status: ToastParams[\"status\"]\n    hideProgressBar?: boolean\n    paused?: boolean\n  }\n>(({ duration, status, hideProgressBar, className, paused, ...props }, ref) => {\n  if (!duration || status === \"loading\" || hideProgressBar) return null\n  return (\n    <div\n      ref={ref}\n      className={cn(progressBarVariants({ status }), className)}\n      style={{\n        animation: `shrink ${duration}ms linear forwards`,\n        animationPlayState: paused ? \"paused\" : \"running\",\n      }}\n      {...props}\n    >\n      <style>\n        {`\n          @keyframes shrink {\n            from { width: 0%; }\n            to { width: 100%; }\n          }\n        `}\n      </style>\n    </div>\n  )\n})\n\nexport function ToastAction({\n  label,\n  onClick,\n  variant,\n  status,\n}: {\n  label: string\n  onClick: () => void\n  variant: \"primary\" | \"dismiss\"\n  status: ToastParams[\"status\"]\n}) {\n  return (\n    <button\n      onClick={onClick}\n      className={cn(\n        toastActionVariants({ variant }),\n        status === \"default\" &&\n          variant === \"primary\" &&\n          \"bg-black text-white hover:bg-black/90 dark:bg-white dark:text-black dark:hover:bg-white/90\"\n      )}\n    >\n      {label}\n    </button>\n  )\n}\n\n// Animation variants are now handled directly in the Toast provider\n\nexport function Toast({\n  closable,\n  description,\n  duration,\n  onClose,\n  text,\n  title,\n  status = \"default\",\n  loaderVariant,\n  classNames = {},\n  hideProgressBar,\n  actions,\n  paused,\n  animation = \"slide\",\n  position,\n}: ToastParams & { classNames?: ToastClassNames; paused?: boolean }) {\n  return (\n    <div\n      className={cn(\n        toastVariants({ status }),\n        classNames[status as keyof ToastClassNames]\n      )}\n      role={status === \"error\" ? \"alert\" : \"status\"}\n    >\n      <div className=\"flex w-full items-center justify-between\">\n        <ToastLoader\n          status={status}\n          className={cn(\"mr-2\", classNames.loader)}\n          variant={loaderVariant}\n        />\n        <div className=\"flex flex-1 flex-col gap-1\">\n          <ToastTitle text={text ?? title} className={classNames.title} />\n          <ToastDescription\n            description={description}\n            status={status}\n            className={classNames.description}\n          />\n        </div>\n        {closable && !actions && (\n          <ToastCloseButton\n            onClose={onClose!}\n            status={status}\n            className={cn(\"ml-2\", classNames.closeButton)}\n          />\n        )}\n      </div>\n      {actions && (\n        <div className=\"mt-3 flex justify-end gap-2\">\n          {actions.dismiss && (\n            <ToastAction\n              label={actions.dismiss.label}\n              onClick={actions.dismiss.onClick || onClose!}\n              variant=\"dismiss\"\n              status={status}\n            />\n          )}\n          <ToastAction\n            label={actions.primary.label}\n            onClick={actions.primary.onClick}\n            variant=\"primary\"\n            status={status}\n          />\n        </div>\n      )}\n      <ToastProgressBar\n        duration={duration}\n        status={status}\n        hideProgressBar={hideProgressBar}\n        className={classNames.progressBar}\n        paused={paused}\n      />\n    </div>\n  )\n}\n\nToastTitle.displayName = \"ToastTitle\"\nToastDescription.displayName = \"ToastDescription\"\nToastCloseButton.displayName = \"ToastCloseButton\"\nToastLoader.displayName = \"ToastLoader\"\nToastProgressBar.displayName = \"ToastProgressBar\"\n",
      "type": "registry:ui",
      "target": "components/ui/notify/notify.tsx"
    },
    {
      "path": "registry/reusables/ui/notify/notify-provider.tsx",
      "content": "\"use client\"\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { AnimatePresence, motion } from \"framer-motion\"\n\nimport { cn } from \"@/lib/utils\"\n\nimport { Toast } from \"./notify\"\nimport { PromiseHandler, toast } from \"./notify-utils\"\n\nexport type AnimationType = \"slide\" | \"fade\" | \"scale\" | \"bounce\"\n\nexport const DEFAULT_CONFIG = {\n  duration: 4000,\n  position: \"bottom-right\",\n  closable: true,\n  preventDuplicates: false,\n  maxToast: 4,\n  hideProgressBar: false,\n  animation: \"slide\" as AnimationType,\n} as const\n\nconst toastPositionVariants = cva(\"absolute w-full max-w-[420px] p-4 md:p-8\", {\n  variants: {\n    position: {\n      \"top-left\": \"left-0 top-0 md:top-0\",\n      \"top-center\": \"left-1/2 top-0 -translate-x-1/2 transform md:top-0\",\n      \"top-right\": \"right-0 top-0 md:top-0\",\n      \"bottom-left\": \"bottom-0 left-0 md:bottom-0\",\n      \"bottom-center\":\n        \"bottom-0 left-1/2 -translate-x-1/2 transform md:bottom-0\",\n      \"bottom-right\": \"bottom-0 right-0 md:bottom-0\",\n    },\n  },\n  defaultVariants: {\n    position: DEFAULT_CONFIG.position,\n  },\n})\n\ntype ToastPosition = VariantProps<typeof toastPositionVariants>[\"position\"]\n\ninterface ToastState {\n  dismiss: () => void\n  id: string\n  params: ToastParams\n  paused: boolean\n  position?: ToastPosition\n}\n\nexport interface Action {\n  label: string\n  onClick: () => void\n  variant?: \"button\" | \"icon\"\n  icon?: React.ReactNode\n}\n\nexport interface Action {\n  label: string\n  onClick: () => void\n}\n\nexport interface ToastParams {\n  title?: React.ReactNode\n  text?: React.ReactNode\n  description?: React.ReactNode\n  duration?: number\n  id?: string\n  onClose?: () => void\n  status?: \"error\" | \"warning\" | \"success\" | \"info\" | \"default\" | \"loading\"\n  loaderVariant?: \"loader-1\" | \"loader-2\"\n  position?: ToastPosition\n  closable?: boolean\n  hideProgressBar?: boolean\n  preventDuplicates?: boolean\n  maxToast?: number\n  actions?: {\n    primary: Action\n    dismiss?: Omit<Action, \"onClick\"> & { onClick?: () => void }\n  }\n  classNames?: ToastClassNames\n  animation?: AnimationType\n}\n\nexport interface ToastClassNames {\n  error?: string\n  success?: string\n  warning?: string\n  info?: string\n  loading?: string\n  closeButton?: string\n  title?: string\n  description?: string\n  loader?: string\n  progressBar?: string\n  containerClassName?: string\n}\n\nexport interface ToastPromiseOptions<T> {\n  loading: string\n  success: (data: T) => string\n  error?: string\n  position?: ToastPosition\n  duration?: number\n  classNames?: ToastClassNames\n  animation?: AnimationType\n}\n\n// ID Generator\nlet toastId = 0\nconst generateId = () => String(toastId++)\n\nexport interface ToastProviderProps {\n  children: React.ReactNode\n  position?: ToastPosition\n  duration?: number\n  classNames?: ToastClassNames\n  closable?: boolean\n  preventDuplicates?: boolean\n  maxToast?: number\n  hideProgressBar?: boolean\n  animation?: AnimationType\n}\n\nexport function ToastProvider({\n  children,\n  position: defaultPosition = DEFAULT_CONFIG.position,\n  duration = DEFAULT_CONFIG.duration,\n  classNames = {},\n  closable = DEFAULT_CONFIG.closable,\n  preventDuplicates = DEFAULT_CONFIG.preventDuplicates,\n  maxToast = DEFAULT_CONFIG.maxToast,\n  hideProgressBar = DEFAULT_CONFIG.hideProgressBar,\n  animation = DEFAULT_CONFIG.animation,\n}: ToastProviderProps) {\n  const [toasts, setToasts] = useState<ToastState[]>([])\n  const toastsRef = useRef<\n    Record<\n      string,\n      {\n        timeout: NodeJS.Timeout\n        remaining: number\n        startTime: number\n        onClose?: () => void\n      }\n    >\n  >({})\n\n  const dismiss = useCallback((id: string | number) => {\n    setToasts((prev) => prev.filter((t) => t.id !== String(id)))\n    const toast = toastsRef.current[String(id)]\n    if (toast) {\n      clearTimeout(toast.timeout)\n      if (toast.onClose) {\n        toast.onClose()\n      }\n      delete toastsRef.current[String(id)]\n    }\n  }, [])\n\n  // Optimized grouping of toasts by position\n  const toastsByPosition = useMemo(() => {\n    const positions = {} as Record<string, ToastState[]>\n    for (const toast of toasts) {\n      const position = toast.params.position ?? defaultPosition\n      positions[position!] = positions[position!] || []\n      positions[position!].push(toast)\n    }\n    return positions\n  }, [\n    toasts,\n    defaultPosition,\n    dismiss,\n    duration,\n    classNames,\n    closable,\n    preventDuplicates,\n    maxToast,\n    hideProgressBar,\n  ])\n\n  // Using void operator since we only care about the side-effect of setting up handlers\n  // and not the returned value from useMemo\n  // Define these outside the useMemo to avoid circular dependencies\n  const createPush = useCallback(\n    (createDismiss: (id: string) => () => void) => {\n      return (params: ToastParams) => {\n        const id = params.id ?? generateId()\n        const toastDuration = params.duration ?? duration\n\n        if (params.preventDuplicates ?? preventDuplicates) {\n          const isDuplicate = toasts.some(\n            (toast) => toast.params.text === params.text\n          )\n          if (isDuplicate) return id\n        }\n\n        const dismissToast = createDismiss(id)\n\n        setToasts((prev) => {\n          const filteredToasts = prev.filter((t) => t.id !== id)\n          const newToast = {\n            dismiss: dismissToast,\n            id,\n            params: {\n              ...params,\n              duration: toastDuration,\n              closable: params.closable ?? closable,\n              hideProgressBar: params.hideProgressBar ?? hideProgressBar,\n              classNames,\n              position: params.position ?? defaultPosition,\n            },\n            paused: false,\n          }\n          const updatedToasts = [newToast, ...filteredToasts]\n          return updatedToasts.slice(0, params.maxToast ?? maxToast)\n        })\n\n        if (toastsRef.current[id]) {\n          clearTimeout(toastsRef.current[id].timeout)\n        }\n\n        if (toastDuration !== Infinity) {\n          toastsRef.current[id] = {\n            timeout: setTimeout(dismissToast, toastDuration),\n            remaining: toastDuration,\n            startTime: Date.now(),\n            onClose: params.onClose,\n          }\n        }\n\n        return id\n      }\n    },\n    [\n      toasts,\n      preventDuplicates,\n      duration,\n      closable,\n      hideProgressBar,\n      classNames,\n      defaultPosition,\n      maxToast,\n    ]\n  )\n\n  const createPushPromise = useCallback(\n    <T,>(\n      createPush: (params: ToastParams) => string,\n      createDismiss: (id: string) => () => void\n    ) => {\n      return (promise: () => Promise<T>, options: ToastPromiseOptions<T>) => {\n        const id = generateId()\n        const dismiss = createDismiss(id)\n        const position = options.position\n        const toastDuration = options.duration ?? duration\n        const toastClassNames = options.classNames ?? classNames\n        const toastAnimation = options.animation ?? animation\n\n        createPush({\n          status: \"loading\",\n          text: options.loading,\n          id,\n          position,\n          classNames: toastClassNames,\n          duration: toastDuration,\n          animation: toastAnimation,\n        })\n\n        promise()\n          .then((data) => {\n            // Clear any existing timeout\n            if (toastsRef.current[id]) {\n              clearTimeout(toastsRef.current[id].timeout)\n            }\n\n            setToasts((prev) => [\n              {\n                dismiss,\n                id,\n                params: {\n                  status: \"success\",\n                  text: options.success(data),\n                  duration: toastDuration, // Reset full duration\n                  closable: true,\n                  classNames: toastClassNames,\n                  position,\n                  hideProgressBar: hideProgressBar,\n                  animation: toastAnimation,\n                },\n                paused: false,\n              },\n              ...prev.filter((t) => t.id !== id),\n            ])\n\n            // Set new timeout with full duration\n            if (toastDuration !== Infinity) {\n              toastsRef.current[id] = {\n                timeout: setTimeout(dismiss, toastDuration),\n                remaining: toastDuration,\n                startTime: Date.now(),\n              }\n            }\n          })\n          .catch(() => {\n            // Clear any existing timeout\n            if (toastsRef.current[id]) {\n              clearTimeout(toastsRef.current[id].timeout)\n            }\n\n            setToasts((prev) => [\n              {\n                dismiss,\n                id,\n                params: {\n                  status: \"error\",\n                  text: options.error ?? \"Error\",\n                  duration: toastDuration, // Reset full duration\n                  classNames: toastClassNames,\n                  position,\n                  hideProgressBar: hideProgressBar,\n                  animation: toastAnimation,\n                },\n                paused: false,\n              },\n              ...prev.filter((t) => t.id !== id),\n            ])\n\n            // Set new timeout with full duration\n            if (toastDuration !== Infinity) {\n              toastsRef.current[id] = {\n                timeout: setTimeout(dismiss, toastDuration),\n                remaining: toastDuration,\n                startTime: Date.now(),\n              }\n            }\n          })\n\n        return id\n      }\n    },\n    [duration, classNames, animation, hideProgressBar]\n  )\n\n  // Initialize toast methods\n  useMemo(() => {\n    const createDismiss = (id: string) => () => {\n      dismiss(id)\n    }\n\n    // Use the callback functions created outside the useMemo to avoid circular dependencies\n    const push = createPush(createDismiss)\n    const pushPromise = createPushPromise(push, createDismiss)\n\n    toast.setHandlers(push, pushPromise as PromiseHandler, dismiss)\n\n    return { push, pushPromise }\n  }, [dismiss, createPush, createPushPromise])\n\n  const pauseToast = useCallback((id: string) => {\n    if (toastsRef.current[id]) {\n      clearTimeout(toastsRef.current[id].timeout)\n      const remaining =\n        toastsRef.current[id].remaining -\n        (Date.now() - toastsRef.current[id].startTime)\n      toastsRef.current[id].remaining = remaining\n      setToasts((prev) =>\n        prev.map((t) => (t.id === id ? { ...t, paused: true } : t))\n      )\n    }\n  }, [])\n\n  const resumeToast = useCallback(\n    (id: string) => {\n      if (toastsRef.current[id]) {\n        toastsRef.current[id].startTime = Date.now()\n        toastsRef.current[id].timeout = setTimeout(\n          () => dismiss(id),\n          toastsRef.current[id].remaining\n        )\n        setToasts((prev) =>\n          prev.map((t) => (t.id === id ? { ...t, paused: false } : t))\n        )\n      }\n    },\n    [dismiss]\n  )\n\n  useEffect(() => {\n    return () => {\n      Object.values(toastsRef.current).forEach((toast) =>\n        clearTimeout(toast.timeout)\n      )\n      toastsRef.current = {}\n    }\n  }, [])\n\n  return (\n    <>\n      {children}\n      <div\n        role=\"alert\"\n        aria-live=\"polite\"\n        className=\"pointer-events-none fixed inset-0 z-[999999]\"\n      >\n        {Object.entries(toastsByPosition).map(([position, positionToasts]) => (\n          <div\n            key={position}\n            className={cn(\n              toastPositionVariants({\n                position: position as ToastPosition,\n              }),\n              classNames.containerClassName\n            )}\n          >\n            <AnimatePresence mode=\"popLayout\">\n              {positionToasts.map((toast) => {\n                const { id, dismiss, params, paused } = toast\n                const toastAnimation = params.animation || animation\n                const toastPosition = (params.position ||\n                  position) as ToastPosition\n                const isTop = toastPosition?.includes(\"top\")\n                const isRight = toastPosition?.includes(\"right\")\n\n                // Select animation variants based on the animation type\n                let initial, animate, exit\n\n                switch (toastAnimation) {\n                  case \"slide\":\n                    initial = { opacity: 0, x: isRight ? 100 : -100 }\n                    animate = { opacity: 1, x: 0 }\n                    exit = { opacity: 0, x: isRight ? 100 : -100 }\n                    break\n                  case \"fade\":\n                    initial = { opacity: 0 }\n                    animate = { opacity: 1 }\n                    exit = { opacity: 0 }\n                    break\n                  case \"scale\":\n                    initial = { opacity: 0, scale: 0.85 }\n                    animate = { opacity: 1, scale: 1 }\n                    exit = { opacity: 0, scale: 0.85 }\n                    break\n                  case \"bounce\":\n                    initial = { opacity: 0, scale: 0.5 }\n                    animate = { opacity: 1, scale: 1 }\n                    exit = { opacity: 0, scale: 0.5 }\n                    break\n                  default:\n                    initial = { opacity: 0, y: isTop ? -80 : 80 }\n                    animate = { opacity: 1, y: 0 }\n                    exit = { opacity: 0, y: isTop ? -80 : 80 }\n                }\n\n                return (\n                  <motion.div\n                    key={id}\n                    layout\n                    initial={initial}\n                    animate={animate}\n                    exit={exit}\n                    transition={\n                      toastAnimation === \"bounce\" ?\n                        { type: \"spring\", stiffness: 400, damping: 25 }\n                      : { type: \"spring\", stiffness: 300, damping: 30 }\n                    }\n                    className=\"pointer-events-auto mb-3.5 w-full last:mb-0\"\n                    style={{\n                      zIndex:\n                        positionToasts.length - positionToasts.indexOf(toast),\n                    }}\n                    onMouseEnter={() => pauseToast(id)}\n                    onMouseLeave={() => resumeToast(id)}\n                    drag\n                    dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}\n                    dragElastic={0.5}\n                    onDragEnd={(_, info) => {\n                      const threshold = 80\n                      const { x, y } = info.offset\n\n                      if (Math.abs(x) > threshold || Math.abs(y) > threshold) {\n                        dismiss()\n                      }\n                    }}\n                  >\n                    <Toast {...params} onClose={dismiss} paused={paused} />\n                  </motion.div>\n                )\n              })}\n            </AnimatePresence>\n          </div>\n        ))}\n      </div>\n    </>\n  )\n}\n",
      "type": "registry:ui",
      "target": "components/ui/notify/notify-provider.tsx"
    },
    {
      "path": "registry/reusables/ui/notify/notify-utils.ts",
      "content": "import type { ToastParams, ToastPromiseOptions } from \"./notify-provider\"\n\nexport type ToastFunction = (\n  text: React.ReactNode,\n  options?: Partial<ToastParams>\n) => string\n\nexport type PromiseHandler = <T>(\n  promise: () => Promise<T>,\n  options: ToastPromiseOptions<T>\n) => string\n\nexport interface ToastMethods {\n  success: ToastFunction\n  error: ToastFunction\n  warning: ToastFunction\n  info: ToastFunction\n  loading: ToastFunction\n  default: ToastFunction\n  push: (params: ToastParams) => string\n  promise: PromiseHandler\n  dismiss: (id: string | number) => void\n}\n\nclass Toast implements ToastMethods {\n  private emit: ((params: ToastParams) => string) | null = null\n  private emitPromise: PromiseHandler | null = null\n  private emitDismiss: ((id: string | number) => void) | null = null\n\n  setHandlers(\n    emit: (params: ToastParams) => string,\n    promiseHandler: PromiseHandler,\n    dismissHandler: (id: string | number) => void\n  ) {\n    this.emit = emit\n    this.emitPromise = promiseHandler\n    this.emitDismiss = dismissHandler\n  }\n\n  private createToastFn(status: ToastParams[\"status\"]): ToastFunction {\n    return (text, options = {}) => {\n      if (!this.emit)\n        throw new Error(\n          \"Toast not initialized: wrap your app with ToastProvider\"\n        )\n      return this.emit({\n        text,\n        status,\n        ...options,\n      })\n    }\n  }\n\n  /**\n   * Display a success toast notification\n   * @param text - The main message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.success('Profile updated successfully')\n   * toast.success('Files uploaded', { duration: 5000, description: '3 files uploaded' })\n   */\n  success = this.createToastFn(\"success\")\n\n  /**\n   * Display an error toast notification\n   * @param text - The error message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.error('Failed to save changes')\n   * toast.error('Upload failed', { description: 'Network error occurred' })\n   */\n  error = this.createToastFn(\"error\")\n\n  /**\n   * Display a warning toast notification\n   * @param text - The warning message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.warning('Low storage space')\n   * toast.warning('Session expiring', { description: 'Please save your work' })\n   */\n  warning = this.createToastFn(\"warning\")\n\n  /**\n   * Display an info toast notification\n   * @param text - The information message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.info('New updates available')\n   * toast.info('Tips', { description: 'Swipe left to delete' })\n   */\n  info = this.createToastFn(\"info\")\n\n  /**\n   * Display a loading toast notification\n   * @param text - The loading message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.loading('Uploading files...')\n   * toast.loading('Processing', { duration: Infinity })\n   */\n  loading = this.createToastFn(\"loading\")\n\n  /**\n   * Display a default toast notification\n   * @param text - The message to display\n   * @param options - Optional configuration for the toast\n   * @example\n   * toast.default('Something happened')\n   */\n  default = this.createToastFn(\"default\")\n\n  /**\n   * Dismiss a toast notification by its ID\n   * @param id - The ID of the toast to dismiss\n   * @example\n   * const toastId = toast.info('Loading...');\n   * toast.dismiss(toastId);\n   */\n  dismiss = (id: string | number) => {\n    if (this.emitDismiss) {\n      this.emitDismiss(id)\n    }\n  }\n\n  /**\n   * Create a custom toast notification with full control over its properties\n   * @param params - Complete toast parameters\n   * @example\n   * toast.push({\n   *   title: 'Custom Toast',\n   *   status: 'info',\n   *   duration: 3000,\n   *   description: 'This is a custom toast',\n   *   position: 'top-right'\n   * })\n   */\n  push = (params: ToastParams) => {\n    if (!this.emit)\n      throw new Error(\"Toast not initialized: wrap your app with ToastProvider\")\n    return this.emit(params)\n  }\n\n  /**\n   * Handle async operations with loading, success, and error states\n   * @param promise - Function that returns a promise\n   * @param options - Configuration for different states of the promise\n   * @example\n   * toast.promise(\n   *   () => fetchUserData(),\n   *   {\n   *     loading: 'Fetching user...',\n   *     success: (data) => `Welcome ${data.name}!`,\n   *     error: 'Failed to fetch user'\n   *   }\n   * )\n   */\n  promise = <T>(promise: () => Promise<T>, options: ToastPromiseOptions<T>) => {\n    if (!this.emitPromise)\n      throw new Error(\"Toast not initialized: wrap your app with ToastProvider\")\n    return this.emitPromise(promise, options)\n  }\n}\n\nexport const toast = new Toast()\n",
      "type": "registry:ui",
      "target": "components/ui/notify/notify-utils.ts"
    },
    {
      "path": "registry/reusables/ui/notify/index.ts",
      "content": "export * from \"./notify-provider\"\n\nexport { toast } from \"./notify-utils\"\n\nexport { Toast, statusStyles } from \"./notify\"\n",
      "type": "registry:ui",
      "target": "components/ui/notify/index.ts"
    }
  ]
}
